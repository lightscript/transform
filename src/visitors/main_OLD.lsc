import t, { is, isa } from "../types"

import { placeAtNode as atNode, placeTreeAtLocWhenUnplaced as allAtLoc, getLoc, placeAtLoc as atLoc, getSurroundingLoc } from 'ast-loc-utils'

import {
  addImplicitReturns, replaceWithPlainFunction, replaceWithArrowFunction,
  replaceWithBoundFunction
} from "../helpers/functions"
import { blockToExpression, iife } from "../helpers/blocks"
import { getShadowingIdentifiers, checkFalsePositiveReference } from "../helpers/variables"

import { ensureConstructor, bindMethodsInConstructor, bindMethods } from "../transforms/classes"

import { maybeTransformArrayWithSpreadLoops, maybeTransformObjectWithSpreadLoops, maybeTransformJSXExpressionWithSpreadLoop } from "../transforms/comprehension"
import { transformExistentialExpression, transformSafeSpreadElement } from "../transforms/safe"
import { maybeReplaceWithInlinedOperator } from "../transforms/inlinedOperators"
import { transformForInArrayStatement, transformForInObjectStatement, lintForInArrayStatement, lintForInObjectStatement } from "../transforms/for"


import { markIdentifier } from "../state/stdlib"

// Main AST visitor
export default mainPass(compilerState, programPath): void ->
  { opts } = compilerState
  // Main LSC transforms
  programPath.traverse({

    AwaitExpression(path): void ->
      if (path.get("argument")~isa("ArrayExpression")):
        promiseDotAllCall = t.callExpression(
          t.memberExpression(t.identifier("Promise"), t.identifier("all")),
          [path.node.argument],
        );
        path.get("argument").replaceWith(promiseDotAllCall);

    // collect functions to be imported for the stdlib
    ReferencedIdentifier(path): void ->
      if not checkFalsePositiveReference(path):
        compilerState.stdlib~markIdentifier(path)


    LscMatchExpression(path): void ->
      transformMatchExpression(path)

    LscMatchStatement(path): void ->
      transformMatchStatement(path)

  })
