import t, { is, isa } from "../types"

import { placeAtNode as atNode, placeTreeAtLocWhenUnplaced as allAtLoc, getLoc, placeAtLoc as atLoc, getSurroundingLoc } from 'ast-loc-utils'

import {
  addImplicitReturns, replaceWithPlainFunction, replaceWithArrowFunction,
  replaceWithBoundFunction
} from "../helpers/functions"
import { blockToExpression, iife } from "../helpers/blocks"
import { getShadowingIdentifiers, checkFalsePositiveReference } from "../helpers/variables"

import { ensureConstructor, bindMethodsInConstructor, bindMethods } from "../transforms/classes"

import { maybeTransformArrayWithSpreadLoops, maybeTransformObjectWithSpreadLoops, maybeTransformJSXExpressionWithSpreadLoop } from "../transforms/comprehension"
import { transformExistentialExpression, transformSafeSpreadElement } from "../transforms/safe"
import { maybeReplaceWithInlinedOperator } from "../transforms/inlinedOperators"
import { transformForInArrayStatement, transformForInObjectStatement, lintForInArrayStatement, lintForInObjectStatement } from "../transforms/for"


import { markIdentifier } from "../state/stdlib"

// Main AST visitor
export default mainPass(compilerState, programPath): void ->
  { opts } = compilerState
  // Main LSC transforms
  programPath.traverse({

    ClassBody(path): void ->
      let fatArrows = [], fatStaticArrows = [], constructorPath;
      path.node.body.forEach((method, i) => {
        if (!t.isMethod(method)) return;

        if (method.kind === "constructor") {
          now constructorPath = path.get(`body.${i}.body`);
        } else if (method.static && method.skinny === false) {
          fatStaticArrows.push(method.key);
          method.skinny = true; // prevent infinite recursion
        } else if (method.skinny === false) {
          fatArrows.push(method.key);
          method.skinny = true; // prevent infinite recursion
        }
      });

      let maybeAddSuper = path.parentPath.node.superClass && constructorPath;
      if (fatArrows.length || maybeAddSuper) {
        now constructorPath = ensureConstructor(path.parentPath, constructorPath, true);
      }

      if (fatArrows.length) {
        bindMethodsInConstructor(path.parentPath, constructorPath, fatArrows);
      }

      if (fatStaticArrows.length) {
        bindMethods(path.parentPath, fatStaticArrows);
      }

    JSXExpressionContainer(path): void ->
      path~maybeTransformJSXExpressionWithSpreadLoop()

    ArrayExpression(path): void ->
      path~maybeTransformArrayWithSpreadLoops()

    ObjectExpression(path): void ->
      // ObjectExpression may get replaced with an IIFE here...
      if path~maybeTransformObjectWithSpreadLoops(): path.resync()

    SpreadElement(path): void ->
      // TODO: Verify this is not a SpreadProperty...
      if not path.node._safe: // prevent infinite recursion
        path~transformSafeSpreadElement()

    Function: {
      enter(path): void ->
        if path.node~isa("FunctionDeclaration"):
          // This is needed because named arrow declarations are new in
          // Lightscript and therefore not acknowledged by Babel's default
          // traversal algorithm for assessing declarations. We must
          // register the declaration by hand here.
          path.getFunctionParent().scope.registerDeclaration(path)

      exit(path): void ->
        addImplicitReturns(path)
    }

    LscIfExpression(path): void ->
      // TODO: better source mapping here -- place implicit null at end of consequent?
      consequent = blockToExpression(path.get("consequent"));
      undef = path.scope.buildUndefinedNode();

      alternate = if path.node.alternate:
        blockToExpression(path.get("alternate"));
      else:
        undef~atNode(path.node)

      path.replaceWith(t.conditionalExpression(path.node.test, consequent, alternate)~atNode(path.node));

    AssignmentExpression(path): void ->
      if (path.node.operator === "<-"):
        path.node.operator = "="

      if is("MemberExpression", path.node.left): return

      if path.node.isNowAssign === false:
        throw path.buildCodeFrameError(
          "Incorrect assignment: to reassign, use `now`; to assign as `const`, put on its own line."
        )

    AwaitExpression(path): void ->
      if (path.get("argument")~isa("ArrayExpression")):
        promiseDotAllCall = t.callExpression(
          t.memberExpression(t.identifier("Promise"), t.identifier("all")),
          [path.node.argument],
        );
        path.get("argument").replaceWith(promiseDotAllCall);

    // collect functions to be imported for the stdlib
    ReferencedIdentifier(path): void ->
      if not checkFalsePositiveReference(path):
        compilerState.stdlib~markIdentifier(path)


    LscMatchExpression(path): void ->
      transformMatchExpression(path)

    LscMatchStatement(path): void ->
      transformMatchStatement(path)

  })
