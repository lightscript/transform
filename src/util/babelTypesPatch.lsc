// Patch @babel/types
//
// This is necessary because @babel/types does not export the API methods that would
// allow the definitions of additional node types.
//
// These methods are copy/pasted from babel-types/src/definitions/utils.js

import { addPluginAliasKey, seal } from './pluginAliasKeys'

export default patchBabelTypes(t) ->
  // Generic builder based on babel-types/src/builders/builder.js
  BUILDER_KEYS = t.BUILDER_KEYS
  makeGenericBuilder(type) ->
    const keys = BUILDER_KEYS[type];
    (...args) ->
      const countArgs = args.length;
      if (countArgs > keys.length) {
        throw new Error(
          `${type}: Too many arguments passed. Received ${countArgs} but can receive no more than ${
            keys.length
          }`,
        );
      }

      const node = { type };

      let i = 0;
      keys.forEach(key => {
        let arg;
        if (i < countArgs) now arg = args[i];
        // if (arg === undefined) arg = loClone(field.default);

        node[key] = arg;
        i++;
      });

      return node;

  t.getType(val) -> {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else if (val === undefined) {
      return "undefined";
    } else {
      return typeof val;
    }
  }

  t.assertEach(callback: Function): Function -> {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;

      for (let i = 0; i < val.length; i++) {
        callback(node, `${key}[${i}]`, val[i]);
      }
    }
    validator.each = callback;
    return validator;
  }

  t.assertOneOf(...vals): Function -> {
    function validate(node, key, val) {
      if (vals.indexOf(val) < 0) {
        throw new TypeError(
          `Property ${key} expected value to be one of ${JSON.stringify(vals)} but got ${JSON.stringify(val)}`
        );
      }
    }

    validate.oneOf = vals;

    return validate;
  }

  t.assertNodeType(...types): Function -> {
    function validate(node, key, val) {
      let valid = false;

      for (const type of types) {
        if (t.is(type, val)) {
          now valid = true;
          break;
        }
      }

      if (!valid) {
        throw new TypeError(
          `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` +
          `but instead got ${JSON.stringify(val && val.type)}`
        );
      }
    }

    validate.oneOfNodeTypes = types;

    return validate;
  }

  t.assertNodeOrValueType(...types): Function -> {
    function validate(node, key, val) {
      let valid = false;

      for (const type of types) {
        if (t.getType(val) === type || t.is(type, val)) {
          now valid = true;
          break;
        }
      }

      if (!valid) {
        throw new TypeError(
          `Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} ` +
          `but instead got ${JSON.stringify(val && val.type)}`
        );
      }
    }

    validate.oneOfNodeOrValueTypes = types;

    return validate;
  }

  t.assertValueType(type: string): Function -> {
    function validate(node, key, val) {
      const valid = t.getType(val) === type;

      if (!valid) {
        throw new TypeError(`Property ${key} expected type of ${type} but got ${t.getType(val)}`);
      }
    }

    validate.type = type;

    return validate;
  }

  t.chain(...fns): Function -> {
    function validate(...args) {
      for (const fn of fns) {
        fn(...args);
      }
    }
    validate.chainOf = fns;
    return validate;
  }

  t.hasType(type: string): boolean -> {
    return (t.TYPES.indexOf(type) > -1)
  }

  t.definePluginType(
    type: string,
    opts: {
      fields?: Object;
      visitor?: Array<string>;
      aliases?: Array<string>;
      builder?: Array<string>;
      inherits?: string;
      deprecatedAlias?: string;
    } = {},
  ) -> {
    // No duplicate reg
    if (t.TYPES.indexOf(type) > -1) {
      throw new Error(`Duplicate registration of plugin type ${type}`)
    }

    // Babel does store[opts.inherits] here, but that var is not exported.
    // So we reconstruct the inherited opts from the records.
    const inherits = {};
    if (opts.inherits) {
      inherits.visitor = t.VISITOR_KEYS[opts.inherits];
      inherits.builder = t.BUILDER_KEYS[opts.inherits];
      inherits.fields = t.NODE_FIELDS[opts.inherits];
      inherits.aliases = t.ALIAS_KEYS[opts.inherits];
    }

    opts.fields  = opts.fields || inherits.fields || {};
    opts.visitor = opts.visitor || inherits.visitor || [];
    opts.aliases = opts.aliases || inherits.aliases || [];
    opts.builder = opts.builder || inherits.builder || opts.visitor || [];
    opts.pluginAliases = opts.pluginAliases || [];

    if (opts.deprecatedAlias) {
      t.DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }

    // ensure all field keys are represented in `fields`
    for (const key of (opts.visitor.concat(opts.builder): Array<string>)) {
      opts.fields[key] = opts.fields[key] || {};
    }

    for (const key in opts.fields) {
      const field = opts.fields[key];

      if (opts.builder.indexOf(key) === -1) {
        field.optional = true;
      }
      if (field.default === undefined) {
        field.default = null;
      } else if (!field.validate) {
        field.validate = t.assertValueType(t.getType(field.default));
      }
    }

    t.VISITOR_KEYS[type] = opts.visitor;
    t.BUILDER_KEYS[type] = opts.builder;
    t.NODE_FIELDS[type]  = opts.fields;
    t.ALIAS_KEYS[type]   = opts.aliases;

    // Babel assembles its TYPES list internally after it finishes internal registration.
    // Here we add our newly registered type by hand.
    // see https://github.com/babel/babel/pull/4886
    t.TYPES.push(type);

    opts.aliases.forEach((alias) => {
      t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [alias];
      t.FLIPPED_ALIAS_KEYS[alias].push(type);

      // See above
      if (!t.TYPES[alias]) t.TYPES.push(alias);
    });

    // Add plugin-only aliases
    opts.pluginAliases.forEach((alias) => {
      addPluginAliasKey(type, alias)
    })
    seal(type)

    // Create a builder for the new node type.
    // Babel does this through code generation but we must do it manually
    t[type] = makeGenericBuilder(type)
  }

  t
