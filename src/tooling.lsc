// API for external tools, such as the linter, that share functionality with
// the compiler.
import { Options } from './state/options'
import parseConfigurationDirectives from './util/parseConfigurationDirectives'
import * as parser from "@lightscript/parser"
import { everyLodashMethod } from './state/imports'

findBabelConfig = require('find-babel-config')

findConfigEntry(babelConfig, type, pluginName) ->
  for elem p in (babelConfig[type] or []):
    if p == pluginName:
      return {}
    elif p?[0] == pluginName:
      return p[1]

tryConfigEntries(babelConfig, list) ->
  if not babelConfig: return {}
  let x
  for elem [ type, pluginName ] in list:
    now x = findConfigEntry(babelConfig, type, pluginName)
    if x: return x
  {}

// Given a file path, locate the applicable .babelrc and extract the options
// pertinent to the LightScript plugin.
export locateBabelConfig(filePath) ->
  // Check if filePath is nonsense
  if (not filePath) or filePath == "unknown" or filePath == "repl":
    return null
  // Use find-babel-config
  confData = findBabelConfig.sync(filePath)
  confData.config

export getPluginConfig(babelConfig) ->
  babelConfig~tryConfigEntries([
    ["presets", "@lightscript"]
    ["presets", "module:@lightscript/babel-preset"]
    ["plugins", "module:@lightscript/transform"]
  ])

// Obtain compiler configuration information using the same algorithms used
// by the compiler itself. Loads .babelrc and configuration directives.
export getCompilerConfiguration(filePath, code, opts = {}) ->
  pluginOpts = getPluginConfig(locateBabelConfig(filePath))

  // Merge special opts
  for key k, val v in opts:
    if (k != "preset" and k != "plugin"):
      pluginOpts[k] = v

  compilerOpts = new Options(null)
  compilerOpts.setOptions({ filename: filePath }, opts.parserOpts, pluginOpts)
  directiveOpts = parseConfigurationDirectives(code)
  compilerOpts.setPreParseOptions(null, directiveOpts)

  compilerOpts

// Parse code, including configuration directives, generating parser options
// the same way the compiler does. Returns a babylon ast.
export parse(code, compilerConfig) ->
  parser.parse(code, compilerConfig.getParserOptions())

// Linter needs to know about implicit lodash imports
export isPotentialImplicitLodashImport(compilerConfig, name): boolean ->
  if compilerConfig.lodashEnabled():
    if everyLodashMethod[name]: return true
  false
