import { CompilerState } from './state'

export default LightScript(babel) ->
  plugin = {
    manipulateOptions(opts, parserOpts): void ->
      state = new CompilerState(babel)
      state.manipulateOptions(opts, parserOpts, plugin)

    parserOverride(code, parserOpts, babylon7) ->
      // Retrieve compiler state created by manipulateOptions
      state = parserOpts.lscCompiler
      state.parserOverride(code, parserOpts)

    visitor: {
      Program(path, state): void ->
        compilerState = state.file.opts.lscCompiler
        compilerState.visitProgram(path, state)

        // // Skip non-LightScript code
        // if not state.file.isLightScript: return

        // // Obtain compiler state created during early processing
        // compiler = state.file.lscCompiler

        // ////////// Initialize compilation run
        // compiler~preCompileInitialization(path)

        // ////////// AST visitation and transformation
        // // First pass: Perform basic ast fixups (block bodies, etc)
        // compiler~firstPass(path)
        // // Second pass: placeholders, comprehensions
        // compiler~secondPass(path)
        // // Third pass: transform optional chains
        // compiler~thirdPass(path)
        // // Main ast visitor
        // compiler~mainPass(path)

        // ////////// Post-processing
        // // Fix up loose ends like adding `import` statements
        // compiler~postprocess()
    }
  }
